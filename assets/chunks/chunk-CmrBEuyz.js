function Z(e){return Array.from(new Set(e))}const M="0.4.177",C={projectName:"Vike",projectVersion:M},x=`_${C.projectName.toLowerCase()}`;function v(e,t){const n=ee();return n[e]=n[e]||t}function ee(){return globalThis[x]=globalThis[x]||{}}const c=new Proxy({},{get:(e,t)=>n=>t!=="code"?n:`\`${n}\``}),p=v("assertPackageInstances.ts",{instances:[],alreadyLogged:new Set}),te="The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict",J="Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";function D(){{const e=Z(p.instances);re(e.length<=1,`vike@${c.bold(e[0])} and vike@${c.bold(e[1])} loaded but only one version should be loaded`)}p.checkSingleInstance&&p.instances.length>1&&L(!1,J,{onlyOnce:!0,showStackTrace:!0})}function Ce(e){L(p.isClientRouting!==!1,te,{onlyOnce:!0,showStackTrace:!0}),L(p.isClientRouting===void 0,J,{onlyOnce:!0,showStackTrace:!0}),p.isClientRouting=!0,p.checkSingleInstance=!0,D()}function ne(){p.instances.push(C.projectVersion),D()}function re(e,t){if(e)return;const n=`[vike][Wrong Usage] ${t}`;throw new Error(n)}function L(e,t,{onlyOnce:n,showStackTrace:r}){if(e)return;const i=`[vike][Warning] ${t}`;if(n){const{alreadyLogged:o}=p,a=n===!0?i:n;if(o.has(a))return;o.add(a)}console.warn(r?new Error(i):i)}function ie(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function S(e,t){const n=new Error(e);return ie()&&(n.stack=oe(n.stack,t)),n}function oe(e,t){if(!e)return e;const n=ae(e);let r=0;return n.filter(o=>o.includes(" (internal/")||o.includes(" (node:internal")?!1:r<t&&se(o)?(r++,!1):!0).join(`
`)}function se(e){return e.startsWith("    at ")}function ae(e){return e.split(/\r?\n/)}function R(e){return typeof e=="object"&&e!==null}const u=v("utils/assert.ts",{alreadyLogged:new Set,logger(e,t){t==="info"?console.log(e):console.warn(e)},showStackTraceList:new WeakSet});ne();const ce="[vike]",ue=`[vike@${C.projectVersion}]`,O=2;function s(e,t){if(e)return;const n=(()=>{if(!t)return null;const a=typeof t=="string"?t:JSON.stringify(t);return c.dim(`Debug info (for Vike maintainers; you can ignore this): ${a}`)})();let i=[`You stumbled upon a Vike bug. Go to ${c.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,n].filter(Boolean).join(" ");i=k(i),i=T(i,"Bug"),i=$(i,!0);const o=S(i,O);throw u.onBeforeLog?.(),o}function b(e,t,{showStackTrace:n}={}){if(e)return;n=n||u.alwaysShowStackTrace,t=k(t),t=T(t,"Wrong Usage"),t=$(t);const r=S(t,O);throw n&&u.showStackTraceList.add(r),u.onBeforeLog?.(),r}function le(e){return e=k(e),e=T(e,"Error"),e=$(e),S(e,O)}function P(e,t,{onlyOnce:n,showStackTrace:r}){if(!e){if(r=r||u.alwaysShowStackTrace,t=k(t),t=T(t,"Warning"),t=$(t),n){const{alreadyLogged:i}=u,o=n===!0?t:n;if(i.has(o))return;i.add(o)}if(u.onBeforeLog?.(),r){const i=S(t,O);u.showStackTraceList.add(i),u.logger(i,"warn")}else u.logger(t,"warn")}}function Pe(e,t,{onlyOnce:n}){if(t=k(t),t=$(t),n){const{alreadyLogged:r}=u,i=t;if(r.has(i))return;r.add(i)}u.onBeforeLog?.(),u.logger(t,"info")}function T(e,t){let n=`[${t}]`;const r=t==="Warning"?"yellow":"red";return n=c.bold(c[r](n)),`${n}${e}`}function k(e){return e.startsWith("[")?e:` ${e}`}function $(e,t=!1){return`${t?ue:ce}${e}`}function _(e){const t=e/1e3;if(t<120){const n=N(t);return`${n} second${B(n)}`}{const n=t/60,r=N(n);return`${r} minute${B(r)}`}}function N(e){let t=e.toFixed(1);return t.endsWith(".0")&&(t=t.slice(0,-2)),t}function B(e){return e==="1"?"":"s"}const E=v("utils/executeHook.ts",{userHookErrors:new WeakMap,pageContext:null});function Ie(e,t,n){const{hookName:r,hookFilePath:i,hookTimeout:{error:o,warning:a}}=t;let d,h;const j=new Promise((l,m)=>{d=y=>{g(),l(y)},h=y=>{g(),m(y)}}),g=()=>{f&&clearTimeout(f),w&&clearTimeout(w)},f=V(a)&&setTimeout(()=>{P(!1,`The ${r}() hook defined by ${i} is slow: it's taking more than ${_(a)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},a),w=V(o)&&setTimeout(()=>{const l=le(`The ${r}() hook defined by ${i} timed out: it didn't finish after ${_(o)} (https://vike.dev/hooksTimeout)`);h(l)},o);return(async()=>{try{fe(n);const l=await e();d(l)}catch(l){R(l)&&E.userHookErrors.set(l,{hookName:r,hookFilePath:i}),h(l)}})(),j}function V(e){return!!e&&e!==1/0}function fe(e){E.pageContext=e,Promise.resolve().then(()=>{E.pageContext=null})}function G(){return typeof window<"u"&&typeof window.scrollY=="number"}const Y=v("utils/assertRouterType.ts",{});function de(){pe(he()),Y.isClientRouting=!0}function he(){return Y.isClientRouting!==!1}function pe(e){b(G(),`${c.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),P(e,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function ge(e){return e instanceof Function||typeof e=="function"}function U(e){return Array.isArray(e)}function be(e){return U(e)&&e.every(t=>typeof t=="string")}function me(e){return R(e)&&Object.values(e).every(t=>typeof t=="string")}function we(e,t,n){if(!R(e))return!1;if(!(t in e))return n==="undefined";if(n===void 0)return!0;const r=e[t];return n==="undefined"?r===void 0:n==="array"?U(r):n==="object"?R(r):n==="string[]"?be(r):n==="string{}"?me(r):n==="function"?ge(r):U(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function q(e,t){t&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(t))}function z(e,t,n){return typeof e=="string"?F(e.split(""),t,n).join(""):F(e,t,n)}function F(e,t,n){const r=[];let i=t>=0?t:e.length+t;s(i>=0&&i<=e.length);let o=n>=0?n:e.length+n;for(s(o>=0&&o<=e.length);!(i===o||(i===e.length&&(i=0),i===o));){const a=e[i];s(a!==void 0),r.push(a),i++}return r}const K=["http://","https://","tauri://","file://"];function Q(e){return K.some(t=>e.startsWith(t))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||e===""}function xe(e,t){s(t.includes(" but ")),b(typeof e=="string",`${t} should be a string`),!Q(e)&&(!e.startsWith("/")&&!e.includes(":")?b(!1,`${t} is ${c.cyan(e)} and it should be /${c.cyan(e)} instead (URL pathnames should start with a leading slash)`):b(!1,`${t} isn't a valid URL`))}function _e(e,t){s(Q(e)),s(t.startsWith("/"));const[n,...r]=e.split("#");s(n!==void 0);const i=["",...r].join("#")||null;s(i===null||i.startsWith("#"));const o=i===null?"":A(i.slice(1)),[a,...d]=n.split("?");s(a!==void 0);const h=["",...d].join("?")||null;s(h===null||h.startsWith("?"));const j={},g={};Array.from(new URLSearchParams(h||"")).forEach(([W,I])=>{j[W]=I,g[W]=[...g.hasOwnProperty(W)?g[W]:[],I]});const{origin:f,pathname:w}=ke(a,t);s(f===null||f===A(f)),s(w.startsWith("/")),s(f===null||e.startsWith(f));const l=a.slice((f||"").length);ve(e,f,l,h,i);let{pathname:m,hasBaseServer:y}=We(w,t);return m=ye(m),s(m.startsWith("/")),{origin:f,pathname:m,pathnameOriginal:l,hasBaseServer:y,search:j,searchAll:g,searchOriginal:h,hash:o,hashOriginal:i}}function A(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function ye(e){return e=e.replace(/\s+$/,""),e=e.split("/").map(t=>A(t).split("/").join("%2F")).join("/"),e}function ke(e,t){s(!e.includes("?")&&!e.includes("#"));{const{origin:n,pathname:r}=H(e);if(n)return{origin:n,pathname:r};s(r===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{const n=typeof window<"u"?window?.document?.baseURI:void 0;let r;return n?r=H(n.split("?")[0]).pathname:r=t,{origin:null,pathname:$e(e,r)}}}function H(e){if(K.some(t=>e.startsWith(t))){const[t,n,r,...i]=e.split("/"),o=[t,n,r].join("/"),a=["",...i].join("/")||"/";return{origin:o,pathname:a}}else return{pathname:e,origin:null}}function $e(e,t){const n=t.split("/"),r=e.split("/");let i=t.endsWith("/");e.startsWith(".")&&n.pop();for(const a in r){const d=r[a];d==""&&a==="0"||d!="."&&(d==".."?n.pop():(i=!1,n.push(d)))}let o=n.join("/");return i&&!o.endsWith("/")&&(o+="/"),o.startsWith("/")||(o="/"+o),o}function je(e){s(e.startsWith("/")),s(!e.includes("?")),s(!e.includes("#"))}function We(e,t){je(e),s(Re(t));let n=e;if(s(n.startsWith("/")),s(t.startsWith("/")),t==="/")return{pathname:e,hasBaseServer:!0};let r=t;return t.endsWith("/")&&n===z(t,0,-1)&&(r=z(t,0,-1),s(n===r)),n.startsWith(r)?(s(n.startsWith("/")||n.startsWith("http")),s(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),s(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}function Re(e){return e.startsWith("/")}function ve(e,t,n,r,i){const o=Se(t,n,r,i);s(e===o)}function Se(e,t,n,r){return`${e||""}${t}${n||""}${r||""}`}function Oe(e){return/^[a-z0-9][a-z0-9\.\+\-]*:/i.test(e)}function Te(e,t,n=r=>r){if(s(e.length>0),e.length===1)return n(e[0]);const r=e.slice(0,e.length-1),i=e[e.length-1];return r.map(n).join(", ")+`, ${t} `+n(i)}G()&&de();function Ne(e,t){const n="throw redirect()";Ae(e,n);const r=[JSON.stringify(e)];t?(Ee(t,[301,302],"redirect"),r.push(String(t))):t=302;const i={};return q(i,{_abortCaller:n,_abortCall:`redirect(${r.join(", ")})`,_urlRedirect:{url:e,statusCode:t}}),Le(i)}function Le(e){const t=new Error("AbortRender");return q(t,{_pageContextAbort:e,[X]:!0}),t}const X="_isAbortError";function Be(e){return typeof e=="object"&&e!==null&&X in e}function Ve(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(s(we(e,"_abortCall","string")),!0):!1}function Ee(e,t,n){const r=Te(t.map(i=>i.toString()),"or");P(t.includes(e),`Unepexected status code ${e} passed to ${n}(), we recommend ${r} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${e} should be added.)`,{onlyOnce:!0})}function ze(e){Ue(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function Ue(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const i=t.indexOf(r);if(i!==-1){const o=[...t.slice(i),r].map(a=>`render('${a}')`).join(" => ");b(!1,`Infinite loop of render() calls: ${o}`)}}t.push(r)})}function Fe(e,t){const n=[e>0&&c.cyan("throw render('/some-url')"),t>0&&c.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");b(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function Ae(e,t,n){b(e.startsWith("/")||Oe(e),[`Invalid URL ${c.cyan(e)} passed to ${c.cyan(t)}:`,`the URL should start with ${c.cyan("/")}`,`or a valid protocol (${c.cyan("https:")}, ${c.cyan("ipfs:")}, ...)`].filter(Boolean).join(" "))}export{Le as A,Be as B,Ce as C,s as a,b,U as c,P as d,R as e,G as f,v as g,we as h,ge as i,de as j,_e as k,Ie as l,Ve as m,le as n,q as o,c as p,Re as q,Ne as r,z as s,Q as t,Z as u,Pe as v,Te as w,xe as x,Fe as y,ze as z};
