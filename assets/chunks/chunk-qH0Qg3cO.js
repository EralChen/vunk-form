import{bc as l,bd as w,be as h}from"./chunk-BCtBXoS3.js";import"./chunk-Zpopvlea.js";import"./chunk-UADQAoLm.js";import"./chunk-DxfIC8xT.js";import"./chunk-fEI7Cr-O.js";import"./chunk-Ch0SDxT-.js";import"./chunk-DBIPdCjN.js";function a(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function c(e){return Array.isArray(e)?e.map(t=>w(t)):w(e)}function S(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function d(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function n(e,t){return(await d()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function m(e,t){const r=await d();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function b(e){return n("extendedSpatialReferenceInfo",[e])}async function L(e,t){return c(await n("clip",[a(e),e,t]))}async function T(e,t){return c(await n("cut",[a(e),e,t]))}function V(e,t){return n("contains",[a(e),e,t])}function v(e,t){return n("crosses",[a(e),e,t])}function E(e,t,r){return n("distance",[a(e),e,t,r])}function z(e,t){return n("equals",[a(e),e,t])}function H(e,t){return n("intersects",[a(e),e,t])}function I(e,t){return n("touches",[a(e),e,t])}function P(e,t){return n("within",[a(e),e,t])}function j(e,t){return n("disjoint",[a(e),e,t])}function k(e,t){return n("overlaps",[a(e),e,t])}function q(e,t,r){return n("relate",[a(e),e,t,r])}function B(e){return n("isSimple",[a(e),e])}async function C(e){return c(await n("simplify",[a(e),e]))}async function G(e,t=!1){return c(await n("convexHull",[a(e),e,t]))}async function $(e,t){return c(await n("difference",[a(e),e,t]))}async function W(e,t){return c(await n("symmetricDifference",[a(e),e,t]))}async function F(e,t){return c(await n("intersect",[a(e),e,t]))}async function K(e,t=null){const r=S(e,t);return c(await n("union",[a(r),r]))}async function M(e,t,r,i,s,u){return c(await n("offset",[a(e),e,t,r,i,s,u]))}async function Q(e,t,r,i=!1){const s=[a(e),e,t,r,i];return c(await n("buffer",s))}async function U(e,t,r,i,s,u){const g=[a(e),e,t,r,i,s,u];return c(await n("geodesicBuffer",g))}async function X(e,t,r=!0){const i=await n("nearestCoordinate",[a(e),e,t,r]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function Y(e,t){const r=await n("nearestVertex",[a(e),e,t]);return{...r,coordinate:l.fromJSON(r.coordinate)}}async function Z(e,t,r,i){return(await n("nearestVertices",[a(e),e,t,r,i])).map(s=>({...s,coordinate:l.fromJSON(s.coordinate)}))}function y(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function _(e,t,r){if(e==null)throw new o;const i=e.spatialReference;if((r=r??y(e))==null)throw new o;const s=e.constructor.fromJSON(await n("rotate",[i,e,t,r]));return s.spatialReference=i,s}async function ee(e,t){if(e==null)throw new o;const r=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await n("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function te(e,t){if(e==null)throw new o;const r=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await n("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function re(e,t,r,i){return c(await n("generalize",[a(e),e,t,r,i]))}async function ne(e,t,r){return c(await n("densify",[a(e),e,t,r]))}async function ae(e,t,r,i=0){return c(await n("geodesicDensify",[a(e),e,t,r,i]))}function ie(e,t){return n("planarArea",[a(e),e,t])}function ce(e,t){return n("planarLength",[a(e),e,t])}function se(e,t,r){return n("geodesicArea",[a(e),e,t,r])}function oe(e,t,r){return n("geodesicLength",[a(e),e,t,r])}async function ue(e,t){return c(await n("intersectLinesToPoints",[a(e),e,t]))}async function fe(e,t){await m("changeDefaultSpatialReferenceTolerance",[e,t])}async function le(e){await m("clearDefaultSpatialReferenceTolerance",[e])}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{Q as buffer,fe as changeDefaultSpatialReferenceTolerance,le as clearDefaultSpatialReferenceTolerance,L as clip,V as contains,G as convexHull,v as crosses,T as cut,ne as densify,$ as difference,j as disjoint,E as distance,z as equals,b as extendedSpatialReferenceInfo,ee as flipHorizontal,te as flipVertical,re as generalize,se as geodesicArea,U as geodesicBuffer,ae as geodesicDensify,oe as geodesicLength,F as intersect,ue as intersectLinesToPoints,H as intersects,B as isSimple,X as nearestCoordinate,Y as nearestVertex,Z as nearestVertices,M as offset,k as overlaps,ie as planarArea,ce as planarLength,q as relate,_ as rotate,C as simplify,W as symmetricDifference,I as touches,K as union,P as within};
